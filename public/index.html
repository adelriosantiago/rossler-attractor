<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Strange Attractors</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Righteous&family=Roboto:wght@300&display=swap"
      rel="stylesheet"
    />
    <style>
      html,
      body,
      #container {
        margin: 0px;
        padding: 0px;
        width: 100%;
        height: 100%;
      }
      h1,
      h2,
      h3,
      h4,
      h5,
      h6,
      p,
      a {
        text-decoration: none;
        font-family: "Righteous", cursive;
        text-transform: uppercase;
      }
      #regen {
        position: fixed;
        top: 70px;
        left: 20px;
        color: white;
        display: inline-block;
        font-size: 12px;
        padding: 0.7em 1.4em;
        margin: 0 0.3em 0.3em 0;
        border-radius: 0.15em;
        box-sizing: border-box;
        font-weight: 400;
        color: #ffffff;
        background-color: #484848;
        box-shadow: inset 0 -0.6em 0 -0.35em rgba(0, 0, 0, 0.17);
        text-align: center;
      }
      #regen:active {
        background-color: #989898;
      }
      #galaxy-name {
        position: fixed;
        top: 0px;
        left: 20px;
        color: white;
      }
      #galaxy-settings {
        font-family: "Roboto", cursive;
        position: fixed;
        bottom: 0px;
        left: 10px;
        color: white;
      }
      #blog-link {
        font-family: "Roboto", cursive;
        font-size: 10px;
        position: fixed;
        bottom: 10px;
        left: 10px;
        color: white;
      }
    </style>
  </head>
  <body>
    <!-- Load analytics -->
    <script>
      (function (i, s, o, g, r, a, m) {
        i["GoogleAnalyticsObject"] = r;
        (i[r] =
          i[r] ||
          function () {
            (i[r].q = i[r].q || []).push(arguments);
          }),
          (i[r].l = 1 * new Date());
        (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m);
      })(
        window,
        document,
        "script",
        "//www.google-analytics.com/analytics.js",
        "ga"
      );
      ga("create", "UA-43591418-3", "auto");
      ga("send", "pageview");
    </script>
    <h2 id="galaxy-name">lorenz I</h2>
    <h6 id="galaxy-settings"></h6>
    <a
      id="blog-link"
      href="http://adelriosantiago.com/gitblog/eng/strange-attractors"
      >Click here to read blog article</a
    >
    <div id="container"></div>
    <a id="regen" href="#" class="regenerate" onclick="initScene(true)"
      >generate new</a
    >

    <script src="./three.js"></script>
    <script src="./OrbitControls.js"></script>
    <script src="./THREE.MeshLine.js"></script>
    <script src="./namegen.js"></script>

    <script type="x-shader/x-vertex" id="ortho-vs">
      precision highp float;

      attribute vec3 position;
      attribute vec2 uv;

      uniform mat4 modelViewMatrix;
      uniform mat4 projectionMatrix;

      varying vec2 vUv;

      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1. );
      }
    </script>

    <script type="x-shader/x-fragment" id="shift-fs">
      precision highp float;

      uniform sampler2D inputTexture;
      uniform vec2 resolution;

      varying vec2 vUv;

      void main(){
        vec2 inc = vec2( 2., 0. ) / resolution;

        float r = texture2D( inputTexture, vUv - inc.xy ).r;
        float g = texture2D( inputTexture, vUv ).g;
        float b = texture2D( inputTexture, vUv + inc.xy ).b;

        vec3 color = vec3( r, g, b );

        gl_FragColor = vec4( color, 1. );
      }
    </script>

    <script>
      "use strict";

      const NUM_POINTS = 90000;
      let time = 0;
      let renderer, camera, controls, scene;
      let starGeo, stars;
      let container = document.getElementById("container");

      function LorenzAttractor() {
        this.id = "lorenz";

        // Common settings: { a: 6.970773956984983, b: 45.21069279106107. c: 0.40074195636847343 }

        this.a = 10;
        this.b = 28;
        this.c = 8 / 3;

        this.x = 0;
        this.y = 10;
        this.z = 10;

        this.color = "0xffffff";

        this.h = 0.004;
        this.scale = 10;
        this.spread = 0.5;

        this.autoCenter = true;
      }

      LorenzAttractor.prototype.generatePoint = function (x, y, z) {
        let nx = this.a * (y - x);
        let ny = x * (this.b - z) - y;
        let nz = x * y - this.c * z;

        x += this.h * nx;
        y += this.h * ny;
        z += this.h * nz;

        return { x: x, y: y, z: z };
      };

      LorenzAttractor.prototype.randomize = function () {
        this.a = Math.random() * 15 + 5;
        this.b = Math.random() * 45 + 5;
        this.c = (Math.random() * 4 + 1) / 10;

        this.x = (Math.random() - 0.5) * 10;
        this.y = (Math.random() - 0.5) * 10;
        this.z = (Math.random() - 0.5) * 10;

        this.color = `0x${Math.floor(Math.random() * 16777215).toString(16)}`;

        document.getElementById("galaxy-name").innerHTML = namegen();
        document.getElementById(
          "galaxy-settings"
        ).innerHTML = `a: ${this.a}, b: ${this.b}, c: ${this.c}, x: ${this.x}, y: ${this.y}, z: ${this.z}`;
      };

      let resolution = new THREE.Vector2(window.innerWidth, window.innerHeight);
      let smokeLines, solidLines;

      function initScene(randomize) {
        let points = [];

        scene.remove(scene.getObjectByName("att"));
        let attractorObject = new THREE.Object3D();
        attractorObject.name = "att";
        scene.add(attractorObject);

        let attractor = new LorenzAttractor();
        if (randomize) attractor.randomize();
        console.log("New attractor generated:", attractor);

        let p = {
          x: attractor.x,
          y: attractor.y,
          z: attractor.z,
        };

        time = 0;
        for (let j = 0; j < NUM_POINTS; j++) {
          p = attractor.generatePoint(p.x, p.y, p.z);

          if (isNaN(p.x) || isNaN(p.y) || isNaN(p.z)) {
            console.log("Failed, retry");
            initScene(true);
            return;
          }

          points.push(attractor.scale * p.x);
          points.push(attractor.scale * p.y);
          points.push(attractor.scale * p.z);
        }

        // Smoke lines
        var geometry = new THREE.Geometry();
        for (let j = 0; j < points.length; j += 3) {
          let v = new THREE.Vector3(points[j], points[j + 1], points[j + 2]);
          geometry.vertices.push(v);
        }

        geometry.computeBoundingBox();
        let center = geometry.boundingBox.max.clone();
        center.sub(geometry.boundingBox.min);
        center.multiplyScalar(0.5);
        center.add(geometry.boundingBox.min);
        center.multiplyScalar(-1);

        let line = new THREE.MeshLine();
        line.setGeometry(geometry, (p) => {
          return 1;
        });

        smokeLines = new THREE.Mesh(
          line.geometry,
          new THREE.MeshLineMaterial({
            color: new THREE.Color(eval(attractor.color)),
            resolution: resolution,
            sizeAttenuation: true,
            lineWidth: 5 * attractor.scale * attractor.spread,
            opacity: 0.025,
            near: camera.near,
            far: camera.far,
            depthWrite: false,
            depthTest: false,
            transparent: true,
            blending: THREE.AdditiveBlending,
          })
        );
        attractorObject.add(smokeLines);

        // Solid lines
        var geometry = new THREE.BufferGeometry();
        let positions = new Float32Array(points);
        geometry.addAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );

        solidLines = new THREE.Line(
          geometry,
          new THREE.LineBasicMaterial({
            color: new THREE.Color(0xffffff),
            opacity: 0.25,
            transparent: true,
            blending: THREE.AdditiveBlending,
          })
        );
        attractorObject.add(solidLines);

        if (attractor.autoCenter) attractorObject.position.copy(center);
        else attractorObject.position.set(0, 0, 0);
      }

      function createRenderTarget() {
        return new THREE.WebGLRenderTarget(1, 1, {
          wrapS: THREE.ClampToEdgeWrapping,
          wrapT: THREE.ClampToEdgeWrapping,
          format: THREE.RGBAFormat,
          stencilBuffer: false,
          depthBuffer: true,
        });
      }

      let baseFBO;
      let orthoQuad, orthoCamera, orthoScene;
      let shiftShader;

      function init() {
        container = document.getElementById("container");
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.1,
          10000
        );
        camera.target = new THREE.Vector3(0, 0, 0);
        camera.position.set(0, 0, 200);
        camera.lookAt(camera.target);
        scene.add(camera);

        // Star creation
        starGeo = new THREE.Geometry();
        for (let i = 0; i < 3000; i++) {
          let star = new THREE.Vector3(
            Math.random() * 10000 - 5000,
            Math.random() * 10000 - 5000,
            Math.random() * 10000 - 5000
          );
          starGeo.vertices.push(star);
        }

        const sprite = new THREE.TextureLoader().load("./circle.png"); // From https://threejs.org/examples/textures/sprites/circle.png
        const starMaterial = new THREE.PointsMaterial({
          color: 0xaaaaaa,
          size: 10,
          blending: THREE.AdditiveBlending,
          transparent: true,
          depthTest: false,
          sizeAttenuation: true,
          map: sprite,
        });

        stars = new THREE.Points(starGeo, starMaterial);
        scene.add(stars);

        renderer = new THREE.WebGLRenderer({
          antialias: true,
          preserveDrawingBuffer: true,
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x261b1f, 1);
        container.appendChild(renderer.domElement);

        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFShadowMap;

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.1;
        controls.rotateSpeed = 0.1;

        // Base shader
        baseFBO = createRenderTarget();
        shiftShader = new THREE.RawShaderMaterial({
          uniforms: {
            inputTexture: { type: "t", value: baseFBO.texture },
            resolution: { type: "v2", value: resolution },
          },
          vertexShader: document.getElementById("ortho-vs").textContent,
          fragmentShader: document.getElementById("shift-fs").textContent,
        });

        orthoScene = new THREE.Scene();
        orthoCamera = new THREE.OrthographicCamera(
          1 / -2,
          1 / 2,
          1 / 2,
          1 / -2,
          0.00001,
          1000
        );
        orthoQuad = new THREE.Mesh(new THREE.PlaneBufferGeometry(1, 1));
        orthoScene.add(orthoQuad);

        initScene(false);

        onWindowResized();
        window.addEventListener("resize", onWindowResized);

        animate();
      }

      function onWindowResized(event) {
        const w = container.clientWidth;
        const h = container.clientHeight;

        renderer.setSize(w, h);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();

        let dPR = window.devicePixelRatio;
        resolution.set(w * dPR, h * dPR);
        baseFBO.setSize(w * dPR, h * dPR);

        orthoQuad.scale.set(w, h, 1);

        orthoCamera.left = -w / 2;
        orthoCamera.right = w / 2;
        orthoCamera.top = h / 2;
        orthoCamera.bottom = -h / 2;
        orthoCamera.updateProjectionMatrix();
      }

      function animate() {
        requestAnimationFrame(animate);
        controls.update();

        solidLines.geometry.setDrawRange(0, time);
        smokeLines.geometry.setDrawRange(0, time);
        if (time < NUM_POINTS) time += 300;

        renderer.render(scene, camera, baseFBO);
        orthoQuad.material = shiftShader;
        renderer.render(orthoScene, orthoCamera);
      }

      window.addEventListener("load", init);
    </script>
  </body>
</html>

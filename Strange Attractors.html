<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Strange Attractors</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <style>
      html,
      body,
      #container {
        margin: 0px;
        padding: 0px;
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>

    <script src="./three.js"></script>
    <script src="./OrbitControls.js"></script>
    <script src="./Maf.js"></script>
    <script src="./THREE.MeshLine.js"></script>

    <script type="x-shader/x-vertex" id="ortho-vs">
      precision highp float;

      attribute vec3 position;
      attribute vec2 uv;

      uniform mat4 modelViewMatrix;
      uniform mat4 projectionMatrix;

      varying vec2 vUv;

      void main() {

      	vUv = uv;
      	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1. );

      }
    </script>

    <script type="x-shader/x-fragment" id="tilt-shift-fs">
      precision highp float;

      uniform sampler2D inputTexture;
      uniform vec2 resolution;

      varying vec2 vUv;

      float smootherstep(float edge0, float edge1, float x) {

          x = clamp((x - edge0)/(edge1 - edge0), 0.0, 1.0);
          return x*x*x*(x*(x*6. - 15.) + 10.);

      }

      void main(){

      	vec4 sum = vec4( 0. );
      	float d = abs( .5 - vUv.y );
      	vec2 inc = vec2( 0., .005 * smootherstep( 0., .75, d ) );

      	sum += texture2D( inputTexture, ( vUv - inc * 4. ) ) * 0.051;
      	sum += texture2D( inputTexture, ( vUv - inc * 3. ) ) * 0.0918;
      	sum += texture2D( inputTexture, ( vUv - inc * 2. ) ) * 0.12245;
      	sum += texture2D( inputTexture, ( vUv - inc * 1. ) ) * 0.1531;
      	sum += texture2D( inputTexture, ( vUv + inc * 0. ) ) * 0.1633;
      	sum += texture2D( inputTexture, ( vUv + inc * 1. ) ) * 0.1531;
      	sum += texture2D( inputTexture, ( vUv + inc * 2. ) ) * 0.12245;
      	sum += texture2D( inputTexture, ( vUv + inc * 3. ) ) * 0.0918;
      	sum += texture2D( inputTexture, ( vUv + inc * 4. ) ) * 0.051;

      	gl_FragColor = sum;

      }
    </script>

    <script type="x-shader/x-fragment" id="shift-fs">
      precision highp float;

      uniform sampler2D inputTexture;
      uniform vec2 resolution;

      varying vec2 vUv;

      void main(){

      	vec2 inc = vec2( 2., 0. ) / resolution;

      	float r = texture2D( inputTexture, vUv - inc.xy ).r;
      	float g = texture2D( inputTexture, vUv ).g;
      	float b = texture2D( inputTexture, vUv + inc.xy ).b;

      	vec3 color = vec3( r, g, b );
      	//color = vec3( 1. ) - ( vec3( 1. ) - color ) * ( vec3( 1. ) - color );

      	gl_FragColor = vec4( color, 1. );

      }
    </script>

    <script>
      "use strict";

      var NUM_POINTS = 50000;

      var container, renderer, camera, controls, scene;
      var mesh;

      var container = document.getElementById("container");

      function LorenzAttractor() {
        this.id = "lorenz";

        this.a = 10;
        this.b = 28;
        this.c = 8 / 3;

        this.x = 0;
        this.y = 10;
        this.z = 10;

        this.h = 0.004;
        this.scale = 10;
        this.spread = 0.5;
        this.particleSize = 0.1;
        this.autoCenter = true;
      }

      LorenzAttractor.prototype.generatePoint = function (x, y, z) {
        var nx = this.a * (y - x);
        var ny = x * (this.b - z) - y;
        var nz = x * y - this.c * z;

        x += this.h * nx;
        y += this.h * ny;
        z += this.h * nz;

        return { x: x, y: y, z: z };
      };

      LorenzAttractor.prototype.randomize = function () {
        this.a = Maf.randomInRange(5, 20);
        this.b = Maf.randomInRange(5, 50);
        this.c = Maf.randomInRange(0.1, 0.5);

        this.x = Maf.randomInRange(-10, 10);
        this.y = Maf.randomInRange(-10, 10);
        this.z = Maf.randomInRange(-10, 10);
      };

      // Common settings: { a: 6.970773956984983, b: 45.21069279106107. c: 0.40074195636847343 }

      var resolution = new THREE.Vector2(window.innerWidth, window.innerHeight);
      var thinLines, thickLines;
      var attractorObject = new THREE.Object3D();

      function initScene(randomize, hash) {
        while (attractorObject.children.length) {
          attractorObject.remove(attractorObject.children[0]);
        }

        var points = [];
        var particles = [];

        function densityFunction(p) {
          return Maf.parabola(p, 1);
        }

        var attractor = new LorenzAttractor();
        if (randomize) attractor.randomize();
        console.log("New attractor generated:", attractor);

        var p = {
          x: attractor.x,
          y: attractor.y,
          z: attractor.z,
        };

        for (var j = 0; j < NUM_POINTS; j++) {
          p = attractor.generatePoint(p.x, p.y, p.z);

          if (isNaN(p.x) || isNaN(p.y) || isNaN(p.z)) {
            console.log("Failed, retry");
            initScene(randomize);
            return;
          }

          points.push(attractor.scale * p.x);
          points.push(attractor.scale * p.y);
          points.push(attractor.scale * p.z);

          var d =
            Math.random() *
            (2 *
              attractor.spread *
              attractor.scale *
              densityFunction(j / NUM_POINTS));
          var a = Math.random() * Math.PI;
          var b = Math.random() * 2 * Math.PI;

          particles.push(attractor.scale * p.x + d * Math.sin(a) * Math.cos(b));
          particles.push(attractor.scale * p.y + d * Math.sin(a) * Math.sin(b));
          particles.push(attractor.scale * p.z + d * Math.cos(a));
        }

        var geometry = new THREE.Geometry();
        for (var j = 0; j < points.length; j += 3) {
          var v = new THREE.Vector3(points[j], points[j + 1], points[j + 2]);
          geometry.vertices.push(v);
        }

        geometry.computeBoundingBox();

        var center = geometry.boundingBox.max.clone();
        center.sub(geometry.boundingBox.min);
        center.multiplyScalar(0.5);
        center.add(geometry.boundingBox.min);
        center.multiplyScalar(-1);

        var line = new THREE.MeshLine();
        line.setGeometry(geometry, function (p) {
          return densityFunction(p);
        });
        var material = new THREE.MeshLineMaterial({
          color: new THREE.Color(0x00ff00),
          resolution: resolution,
          sizeAttenuation: true,
          lineWidth: 1 * attractor.scale * attractor.spread,
          opacity: 0,
          near: camera.near,
          far: camera.far,
          depthWrite: false,
          depthTest: false,
          transparent: true,
          blending: THREE.AdditiveBlending,
        });
        var mesh = new THREE.Mesh(line.geometry, material);
        attractorObject.add(mesh);
        thinLines = mesh;

        var geometry = new THREE.BufferGeometry();
        var positions = new Float32Array(points);
        geometry.addAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        var material = new THREE.LineBasicMaterial({
          color: new THREE.Color(0xff0000),
          opacity: 0.5,
          transparent: true,
          blending: THREE.AdditiveBlending,
        });

        mesh = new THREE.Line(geometry, material);
        attractorObject.add(mesh);
        thickLines = mesh;

        var pData = [];
        var idData = [];
        var sizeData = [];
        for (var j = 0; j < particles.length; j += 3) {
          var x = particles[j];
          var y = particles[j + 1];
          var z = particles[j + 2];
          var s =
            Maf.randomInRange(0.1, 1) * densityFunction(j / particles.length);

          pData.push(x);
          pData.push(y);
          pData.push(z);
          idData.push(j % 3);
          sizeData.push(s);

          pData.push(x);
          pData.push(y);
          pData.push(z);
          idData.push((j % 3) + 1);
          sizeData.push(s);

          pData.push(x);
          pData.push(y);
          pData.push(z);
          idData.push((j % 3) + 2);
          sizeData.push(s);
        }

        var particleGeometry = new THREE.BufferGeometry();
        var positions = new Float32Array(pData);
        var indices = new Float32Array(idData);
        var sizes = new Float32Array(sizeData);

        particleGeometry.addAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        particleGeometry.addAttribute(
          "vertexId",
          new THREE.BufferAttribute(indices, 1)
        );
        particleGeometry.addAttribute(
          "size",
          new THREE.BufferAttribute(sizes, 1)
        );

        var particleMaterial = new THREE.RawShaderMaterial({
          uniforms: {
            scale: {
              type: "f",
              value: 0.5 * attractor.particleSize * attractor.scale,
            },
            opacity: { type: "f", value: 0 },
            color: { type: "c", value: new THREE.Color(0x0000ff) },
            vertices: {
              type: "v3v",
              value: [
                new THREE.Vector3(-1, -1, 0),
                new THREE.Vector3(1, -1, 0),
                new THREE.Vector3(0, 1, 0),
              ],
            },
            uvs: {
              type: "v2v",
              value: [
                new THREE.Vector3(0, 1),
                new THREE.Vector3(1, 1),
                new THREE.Vector3(0.5, 0),
              ],
            },
          },
          depthTest: false,
          depthWrite: false,
          transparent: true,
          blending: THREE.AdditiveBlending,
        });

        if (attractor.autoCenter) attractorObject.position.copy(center);
        else attractorObject.position.set(0, 0, 0);
      }

      function createRenderTarget() {
        return new THREE.WebGLRenderTarget(1, 1, {
          wrapS: THREE.ClampToEdgeWrapping,
          wrapT: THREE.ClampToEdgeWrapping,
          format: THREE.RGBAFormat,
          stencilBuffer: false,
          depthBuffer: true,
        });
      }

      var baseFBO, shiftFBO, tiltShiftFBO;
      var orthoQuad, orthoCamera, orthoScene;
      var shiftShader;

      function init() {
        container = document.getElementById("container");

        scene = new THREE.Scene();
        scene.add(attractorObject);

        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.1,
          10000
        );
        camera.target = new THREE.Vector3(0, 0, 0);
        camera.position.set(0, 0, 200);
        camera.lookAt(camera.target);
        scene.add(camera);

        renderer = new THREE.WebGLRenderer({
          antialias: !true,
          preserveDrawingBuffer: true,
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x261b1f, 1);
        container.appendChild(renderer.domElement);

        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFShadowMap;

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.1;
        controls.rotateSpeed = 0.1;

        baseFBO = createRenderTarget();
        shiftFBO = createRenderTarget();
        tiltShiftFBO = createRenderTarget();

        shiftShader = new THREE.RawShaderMaterial({
          uniforms: {
            inputTexture: { type: "t", value: baseFBO.texture },
            resolution: { type: "v2", value: resolution },
          },
          vertexShader: document.getElementById("ortho-vs").textContent,
          fragmentShader: document.getElementById("shift-fs").textContent,
        });

        orthoScene = new THREE.Scene();
        orthoCamera = new THREE.OrthographicCamera(
          1 / -2,
          1 / 2,
          1 / 2,
          1 / -2,
          0.00001,
          1000
        );
        orthoQuad = new THREE.Mesh(new THREE.PlaneBufferGeometry(1, 1));
        orthoScene.add(orthoQuad);

        initScene(false);

        onWindowResized();
        fader.show();
        window.addEventListener("resize", onWindowResized);

        animate();
      }

      function onWindowResized(event) {
        var w = container.clientWidth;
        var h = container.clientHeight;

        renderer.setSize(w, h);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();

        var dPR = window.devicePixelRatio;
        resolution.set(w * dPR, h * dPR);

        baseFBO.setSize(w * dPR, h * dPR);
        shiftFBO.setSize(w * dPR, h * dPR);
        tiltShiftFBO.setSize(w * dPR, h * dPR);

        orthoQuad.scale.set(w, h, 1);

        orthoCamera.left = -w / 2;
        orthoCamera.right = w / 2;
        orthoCamera.top = h / 2;
        orthoCamera.bottom = -h / 2;
        orthoCamera.updateProjectionMatrix();
      }

      function Fader() {
        this.draw = 0;
        this.nDraw = 0;
        this.easing = 0;
        this.fading = "";

        this.onFadedIn = function () {};
        this.onFadedOut = function () {};
      }

      Fader.prototype.show = function () {
        this.nDraw = 1;
        this.easing = 0.05;
        this.fading = "in";
      };

      Fader.prototype.hide = function () {
        this.nDraw = 0;
        this.easing = 0.1;
        this.fading = "out";
      };

      Fader.prototype.update = function () {
        this.draw += (this.nDraw - this.draw) * this.easing;

        var epsilon = 0.01;

        if (this.fading === "in") {
          if (this.nDraw - this.draw < epsilon) {
            this.fading = "";
            this.draw = this.nDraw;
            requestAnimationFrame(
              function () {
                this.onFadedIn();
              }.bind(this)
            );
          }
        }

        if (this.fading === "out") {
          if (this.draw - this.nDraw < epsilon) {
            this.fading = "";
            this.draw = this.nDraw;
            requestAnimationFrame(
              function () {
                this.onFadedOut();
              }.bind(this)
            );
          }
        }

        return this.draw;
      };

      var fader = new Fader();

      function animate() {
        requestAnimationFrame(animate);

        controls.update();

        var t = fader.update();
        thinLines.geometry.setDrawRange(
          0,
          thinLines.geometry.attributes.position.count * t
        );
        thickLines.geometry.setDrawRange(
          0,
          thickLines.geometry.attributes.position.count * t
        );

        renderer.render(scene, camera, baseFBO);
        orthoQuad.material = shiftShader;
        renderer.render(orthoScene, orthoCamera, shiftFBO);
        renderer.render(orthoScene, orthoCamera, tiltShiftFBO);
        renderer.render(orthoScene, orthoCamera);
      }

      window.addEventListener("load", init);
    </script>
  </body>
</html>
